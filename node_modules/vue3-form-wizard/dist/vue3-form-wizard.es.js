/*
 * vue3-form-wizard
 * Creator:parsa jiravand
 * vue3-form-wizard is a vue based component with no external depenendcies which simplifies tab wizard management.
 * v0.0.4
 * MIT License
 */

import { openBlock, createElementBlock, renderSlot, normalizeClass, createElementVNode, normalizeStyle, toDisplayString, createCommentVNode, resolveComponent, withKeys, Fragment, renderList, createVNode, normalizeProps, guardReactiveProps, withCtx, createTextVNode, withDirectives, vShow } from "vue";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$3 = {};
const _hoisted_1$3 = {
  class: "wizard-btn",
  tabindex: "-1",
  type: "button"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", _hoisted_1$3, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var WizardButton = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = {
  name: "wizard-step",
  props: {
    tab: {
      type: Object,
      default: () => {
      }
    },
    transition: {
      type: String,
      default: ""
    },
    index: {
      type: Number,
      default: 0
    }
  },
  computed: {
    iconActiveStyle() {
      return {
        backgroundColor: this.tab.color
      };
    },
    stepCheckedStyle() {
      return {
        borderColor: this.tab.color
      };
    },
    errorStyle() {
      return {
        borderColor: this.tab.errorColor,
        backgroundColor: this.tab.errorColor
      };
    },
    stepTitleStyle() {
      let isError = this.tab.validationError;
      return {
        color: isError ? this.tab.errorColor : this.tab.color
      };
    },
    isStepSquare() {
      return this.tab.shape === "square";
    },
    isTabShape() {
      return this.tab.shape === "tab";
    }
  }
};
const _hoisted_1$2 = ["tabindex", "id", "aria-controls", "aria-disabled", "aria-selected"];
const _hoisted_2$1 = {
  key: 1,
  class: "wizard-icon"
};
const _hoisted_3$1 = {
  key: 1,
  class: "wizard-icon"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass({ active: $props.tab.active })
  }, [
    createElementVNode("a", {
      href: "javascript:void(0)",
      class: normalizeClass({ disabled: !$props.tab.checked })
    }, [
      createElementVNode("div", {
        class: normalizeClass(["wizard-icon-circle md", { checked: $props.tab.checked, square_shape: $options.isStepSquare, tab_shape: $options.isTabShape }]),
        role: "tab",
        tabindex: $props.tab.checked ? 0 : "",
        id: `step-${$props.tab.tabId}`,
        "aria-controls": $props.tab.tabId,
        "aria-disabled": $props.tab.active,
        "aria-selected": $props.tab.active,
        style: normalizeStyle([$props.tab.checked ? $options.stepCheckedStyle : {}, $props.tab.validationError ? $options.errorStyle : {}])
      }, [
        $props.tab.active ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["wizard-icon-container", { square_shape: $options.isStepSquare, tab_shape: $options.isTabShape }]),
          style: normalizeStyle([$props.tab.active ? $options.iconActiveStyle : {}, $props.tab.validationError ? $options.errorStyle : {}])
        }, [
          renderSlot(_ctx.$slots, "active-step", {}, () => [
            $props.tab.icon ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass([$props.tab.icon, "wizard-icon"])
            }, null, 2)) : (openBlock(), createElementBlock("i", _hoisted_2$1, toDisplayString($props.index + 1), 1))
          ])
        ], 6)) : createCommentVNode("", true),
        !$props.tab.active ? renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
          !$props.tab.active && $props.tab.icon ? (openBlock(), createElementBlock("i", {
            key: 0,
            class: normalizeClass([$props.tab.icon, "wizard-icon"])
          }, null, 2)) : createCommentVNode("", true),
          !$props.tab.active && !$props.tab.icon ? (openBlock(), createElementBlock("i", _hoisted_3$1, toDisplayString($props.index + 1), 1)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 14, _hoisted_1$2),
      renderSlot(_ctx.$slots, "title", {}, () => [
        createElementVNode("span", {
          class: normalizeClass(["stepTitle", { active: $props.tab.active, has_error: $props.tab.validationError }]),
          style: normalizeStyle($props.tab.active ? $options.stepTitleStyle : {})
        }, toDisplayString($props.tab.title), 7)
      ])
    ], 2)
  ], 2);
}
var WizardStep = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
function getFocusedElementId() {
  return document.activeElement.id;
}
function getFocusedTabIndex(tabs = []) {
  let activeId = getFocusedElementId();
  let tabIndex = tabs.findIndex((tab) => tab.tabId === activeId);
  return tabIndex;
}
function findElementAndFocus(elemId) {
  let elem = document.getElementById(elemId);
  elem.focus();
}
function isPromise(func) {
  return func.then && typeof func.then === "function";
}
var FormWizard_vue_vue_type_style_index_0_lang = "";
const _sfc_main$1 = {
  name: "form-wizard",
  components: {
    WizardButton,
    WizardStep
  },
  props: {
    id: {
      type: String,
      default: "fw_" + new Date().valueOf()
    },
    title: {
      type: String,
      default: "Awesome Wizard"
    },
    subtitle: {
      type: String,
      default: "Split a complicated flow in multiple steps"
    },
    nextButtonText: {
      type: String,
      default: "Next"
    },
    backButtonText: {
      type: String,
      default: "Back"
    },
    finishButtonText: {
      type: String,
      default: "Finish"
    },
    hideButtons: {
      type: Boolean,
      default: false
    },
    validateOnBack: Boolean,
    color: {
      type: String,
      default: "#e74c3c"
    },
    errorColor: {
      type: String,
      default: "#8b0000"
    },
    shape: {
      type: String,
      default: "circle"
    },
    layout: {
      type: String,
      default: "horizontal"
    },
    stepsClasses: {
      type: [String, Array],
      default: ""
    },
    stepSize: {
      type: String,
      default: "md",
      validator: (value) => {
        let acceptedValues = ["xs", "sm", "md", "lg"];
        return acceptedValues.indexOf(value) !== -1;
      }
    },
    transition: {
      type: String,
      default: ""
    },
    startIndex: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0;
      }
    }
  },
  provide() {
    return {
      addTab: this.addTab,
      removeTab: this.removeTab
    };
  },
  data() {
    return {
      activeTabIndex: 0,
      currentPercentage: 0,
      maxStep: 0,
      loading: false,
      tabs: []
    };
  },
  computed: {
    slotProps() {
      return {
        nextTab: this.nextTab,
        prevTab: this.prevTab,
        activeTabIndex: this.activeTabIndex,
        isLastStep: this.isLastStep,
        fillButtonStyle: this.fillButtonStyle
      };
    },
    tabCount() {
      return this.tabs.length;
    },
    isLastStep() {
      return this.activeTabIndex === this.tabCount - 1;
    },
    isVertical() {
      return this.layout === "vertical";
    },
    displayPrevButton() {
      return this.activeTabIndex !== 0;
    },
    stepPercentage() {
      return 1 / (this.tabCount * 2) * 100;
    },
    progressBarStyle() {
      return {
        backgroundColor: this.color,
        width: `${this.progress}%`,
        color: this.color
      };
    },
    fillButtonStyle() {
      return {
        backgroundColor: this.color,
        borderColor: this.color,
        color: "white"
      };
    },
    progress() {
      let percentage = 0;
      if (this.activeTabIndex > 0) {
        let stepsToAdd = 1;
        let stepMultiplier = 2;
        percentage = this.stepPercentage * (this.activeTabIndex * stepMultiplier + stepsToAdd);
      } else {
        percentage = this.stepPercentage;
      }
      return percentage;
    }
  },
  methods: {
    emitTabChange(prevIndex, nextIndex) {
      this.$emit("on-change", prevIndex, nextIndex);
      this.$emit("update:startIndex", nextIndex);
    },
    addTab(item) {
      console.log(item.$vnode);
      console.log(this.$.slots);
      const index = 1;
      item.tabId = `${item.title.replace(/ /g, "")}${index}`;
      this.tabs.splice(index, 0, item);
      if (index < this.activeTabIndex + 1) {
        this.maxStep = index;
        this.changeTab(this.activeTabIndex + 1, index);
      }
    },
    removeTab(item) {
      const tabs = this.tabs;
      const index = tabs.indexOf(item);
      if (index > -1) {
        if (index === this.activeTabIndex) {
          this.maxStep = this.activeTabIndex - 1;
          this.changeTab(this.activeTabIndex, this.activeTabIndex - 1);
        }
        if (index < this.activeTabIndex) {
          this.maxStep = this.activeTabIndex - 1;
          this.activeTabIndex = this.activeTabIndex - 1;
          this.emitTabChange(this.activeTabIndex + 1, this.activeTabIndex);
        }
        tabs.splice(index, 1);
      }
    },
    reset() {
      this.maxStep = 0;
      this.tabs.forEach((tab) => {
        tab.checked = false;
      });
      this.navigateToTab(0);
    },
    activateAll() {
      this.maxStep = this.tabs.length - 1;
      this.tabs.forEach((tab) => {
        tab.checked = true;
      });
    },
    navigateToTab(index) {
      let validate = index > this.activeTabIndex;
      if (index <= this.maxStep) {
        let cb = () => {
          if (validate && index - this.activeTabIndex > 1) {
            this.changeTab(this.activeTabIndex, this.activeTabIndex + 1);
            this.beforeTabChange(this.activeTabIndex, cb);
          } else {
            this.changeTab(this.activeTabIndex, index);
            this.afterTabChange(this.activeTabIndex);
          }
        };
        if (validate) {
          this.beforeTabChange(this.activeTabIndex, cb);
        } else {
          this.setValidationError(null);
          cb();
        }
      }
      return index <= this.maxStep;
    },
    nextTab() {
      let cb = () => {
        if (this.activeTabIndex < this.tabCount - 1) {
          this.changeTab(this.activeTabIndex, this.activeTabIndex + 1);
          this.afterTabChange(this.activeTabIndex);
        } else {
          this.$emit("on-complete");
        }
      };
      this.beforeTabChange(this.activeTabIndex, cb);
    },
    prevTab() {
      let cb = () => {
        if (this.activeTabIndex > 0) {
          this.setValidationError(null);
          this.changeTab(this.activeTabIndex, this.activeTabIndex - 1);
        }
      };
      if (this.validateOnBack) {
        this.beforeTabChange(this.activeTabIndex, cb);
      } else {
        cb();
      }
    },
    focusNextTab() {
      let tabIndex = getFocusedTabIndex(this.tabs);
      if (tabIndex !== -1 && tabIndex < this.tabs.length - 1) {
        let tabToFocus = this.tabs[tabIndex + 1];
        if (tabToFocus.checked) {
          findElementAndFocus(tabToFocus.tabId);
        }
      }
    },
    focusPrevTab() {
      let tabIndex = getFocusedTabIndex(this.tabs);
      if (tabIndex !== -1 && tabIndex > 0) {
        let toFocusId = this.tabs[tabIndex - 1].tabId;
        findElementAndFocus(toFocusId);
      }
    },
    setLoading(value) {
      this.loading = value;
      this.$emit("on-loading", value);
    },
    setValidationError(error) {
      this.tabs[this.activeTabIndex].validationError = error;
      this.$emit("on-error", error);
    },
    validateBeforeChange(promiseFn, callback) {
      this.setValidationError(null);
      if (isPromise(promiseFn)) {
        this.setLoading(true);
        promiseFn.then((res) => {
          this.setLoading(false);
          let validationResult = res === true;
          this.executeBeforeChange(validationResult, callback);
        }).catch((error) => {
          this.setLoading(false);
          this.setValidationError(error);
        });
      } else {
        let validationResult = promiseFn === true;
        this.executeBeforeChange(validationResult, callback);
      }
    },
    executeBeforeChange(validationResult, callback) {
      this.$emit("on-validate", validationResult, this.activeTabIndex);
      if (validationResult) {
        callback();
      } else {
        this.tabs[this.activeTabIndex].validationError = "error";
      }
    },
    beforeTabChange(index, callback) {
      if (this.loading) {
        return;
      }
      let oldTab = this.tabs[index];
      if (oldTab && oldTab.beforeChange !== void 0) {
        let tabChangeRes = oldTab.beforeChange();
        this.validateBeforeChange(tabChangeRes, callback);
      } else {
        callback();
      }
    },
    afterTabChange(index) {
      if (this.loading) {
        return;
      }
      let newTab = this.tabs[index];
      if (newTab && newTab.afterChange !== void 0) {
        newTab.afterChange();
      }
    },
    changeTab(oldIndex, newIndex, emitChangeEvent = true) {
      let oldTab = this.tabs[oldIndex];
      let newTab = this.tabs[newIndex];
      if (oldTab) {
        oldTab.active = false;
      }
      if (newTab) {
        newTab.active = true;
      }
      if (emitChangeEvent && this.activeTabIndex !== newIndex) {
        this.emitTabChange(oldIndex, newIndex);
      }
      this.activeTabIndex = newIndex;
      this.activateTabAndCheckStep(this.activeTabIndex);
      return true;
    },
    tryChangeRoute(tab) {
      if (this.$router && tab.route) {
        this.$router.push(tab.route);
      }
    },
    checkRouteChange(route) {
      let matchingTabIndex = -1;
      let matchingTab = this.tabs.find((tab, index) => {
        let match = tab.route === route;
        if (match) {
          matchingTabIndex = index;
        }
        return match;
      });
      if (matchingTab && !matchingTab.active) {
        const shouldValidate = matchingTabIndex > this.activeTabIndex;
        this.navigateToTab(matchingTabIndex, shouldValidate);
      }
    },
    deactivateTabs() {
      this.tabs.forEach((tab) => {
        tab.active = false;
      });
    },
    activateTab(index) {
      this.deactivateTabs();
      let tab = this.tabs[index];
      if (tab) {
        tab.active = true;
        tab.checked = true;
        this.tryChangeRoute(tab);
      }
    },
    activateTabAndCheckStep(index) {
      this.activateTab(index);
      if (index > this.maxStep) {
        this.maxStep = index;
      }
      this.activeTabIndex = index;
    },
    initializeTabs() {
      if (this.tabs.length > 0 && this.startIndex === 0) {
        this.activateTab(this.activeTabIndex);
      }
      if (this.startIndex < this.tabs.length) {
        this.activateTabAndCheckStep(this.startIndex);
      } else {
        window.console.warn(`Prop startIndex set to ${this.startIndex} is greater than the number of tabs - ${this.tabs.length}. Make sure that the starting index is less than the number of tabs registered`);
      }
    }
  },
  mounted() {
    this.initializeTabs();
  },
  watch: {
    "$route.path"(newRoute) {
      this.checkRouteChange(newRoute);
    }
  }
};
const _hoisted_1$1 = ["id"];
const _hoisted_2 = {
  key: 0,
  class: "wizard-header"
};
const _hoisted_3 = { class: "wizard-title" };
const _hoisted_4 = { class: "category" };
const _hoisted_5 = { class: "wizard-navigation" };
const _hoisted_6 = {
  key: 0,
  class: "wizard-progress-with-circle"
};
const _hoisted_7 = { class: "wizard-tab-content" };
const _hoisted_8 = {
  key: 1,
  class: "wizard-card-footer clearfix"
};
const _hoisted_9 = { class: "wizard-footer-left" };
const _hoisted_10 = { class: "wizard-footer-right" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_wizard_step = resolveComponent("wizard-step");
  const _component_wizard_button = resolveComponent("wizard-button");
  return openBlock(), createElementBlock("div", {
    id: $props.id ? $props.id : "",
    class: normalizeClass(["vue-form-wizard", [$props.stepSize, { vertical: $options.isVertical }]]),
    onKeyup: [
      _cache[6] || (_cache[6] = withKeys((...args) => $options.focusNextTab && $options.focusNextTab(...args), ["right"])),
      _cache[7] || (_cache[7] = withKeys((...args) => $options.focusPrevTab && $options.focusPrevTab(...args), ["left"]))
    ]
  }, [
    _ctx.$slots["title"] ? (openBlock(), createElementBlock("div", _hoisted_2, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createElementVNode("h4", _hoisted_3, toDisplayString($props.title), 1),
        createElementVNode("p", _hoisted_4, toDisplayString($props.subtitle), 1)
      ])
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_5, [
      !$options.isVertical ? (openBlock(), createElementBlock("div", _hoisted_6, [
        createElementVNode("div", {
          class: "wizard-progress-bar",
          style: normalizeStyle($options.progressBarStyle)
        }, null, 4)
      ])) : createCommentVNode("", true),
      createElementVNode("ul", {
        class: normalizeClass(["wizard-nav wizard-nav-pills", $props.stepsClasses]),
        role: "tablist"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.tabs, (tab, index) => {
          return renderSlot(_ctx.$slots, "step", {
            tab,
            index,
            navigateToTab: $options.navigateToTab,
            stepSize: $props.stepSize,
            transition: $props.transition
          }, () => [
            createVNode(_component_wizard_step, {
              tab,
              "step-size": $props.stepSize,
              onClick: ($event) => $options.navigateToTab(index),
              onKeyup: withKeys(($event) => $options.navigateToTab(index), ["enter"]),
              transition: $props.transition,
              index
            }, null, 8, ["tab", "step-size", "onClick", "onKeyup", "transition", "index"])
          ]);
        }), 256))
      ], 2),
      createElementVNode("div", _hoisted_7, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps($options.slotProps)))
      ])
    ]),
    !$props.hideButtons ? (openBlock(), createElementBlock("div", _hoisted_8, [
      renderSlot(_ctx.$slots, "footer", normalizeProps(guardReactiveProps($options.slotProps)), () => [
        createElementVNode("div", _hoisted_9, [
          $options.displayPrevButton ? (openBlock(), createElementBlock("span", {
            key: 0,
            onClick: _cache[0] || (_cache[0] = (...args) => $options.prevTab && $options.prevTab(...args)),
            onKeyup: _cache[1] || (_cache[1] = withKeys((...args) => $options.prevTab && $options.prevTab(...args), ["enter"])),
            role: "button",
            tabindex: "0"
          }, [
            renderSlot(_ctx.$slots, "prev", normalizeProps(guardReactiveProps($options.slotProps)), () => [
              createVNode(_component_wizard_button, {
                style: normalizeStyle($options.fillButtonStyle),
                disabled: $data.loading
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($props.backButtonText), 1)
                ]),
                _: 1
              }, 8, ["style", "disabled"])
            ])
          ], 32)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "custom-buttons-left", normalizeProps(guardReactiveProps($options.slotProps)))
        ]),
        createElementVNode("div", _hoisted_10, [
          renderSlot(_ctx.$slots, "custom-buttons-right", normalizeProps(guardReactiveProps($options.slotProps))),
          $options.isLastStep ? (openBlock(), createElementBlock("span", {
            key: 0,
            onClick: _cache[2] || (_cache[2] = (...args) => $options.nextTab && $options.nextTab(...args)),
            onKeyup: _cache[3] || (_cache[3] = withKeys((...args) => $options.nextTab && $options.nextTab(...args), ["enter"])),
            role: "button",
            tabindex: "0"
          }, [
            renderSlot(_ctx.$slots, "finish", normalizeProps(guardReactiveProps($options.slotProps)), () => [
              createVNode(_component_wizard_button, {
                style: normalizeStyle($options.fillButtonStyle)
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($props.finishButtonText), 1)
                ]),
                _: 1
              }, 8, ["style"])
            ])
          ], 32)) : (openBlock(), createElementBlock("span", {
            key: 1,
            onClick: _cache[4] || (_cache[4] = (...args) => $options.nextTab && $options.nextTab(...args)),
            onKeyup: _cache[5] || (_cache[5] = withKeys((...args) => $options.nextTab && $options.nextTab(...args), ["enter"])),
            role: "button",
            tabindex: "0"
          }, [
            renderSlot(_ctx.$slots, "next", normalizeProps(guardReactiveProps($options.slotProps)), () => [
              createVNode(_component_wizard_button, {
                style: normalizeStyle($options.fillButtonStyle),
                disabled: $data.loading
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($props.nextButtonText), 1)
                ]),
                _: 1
              }, 8, ["style", "disabled"])
            ])
          ], 32))
        ])
      ])
    ])) : createCommentVNode("", true)
  ], 42, _hoisted_1$1);
}
var FormWizard = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = {
  name: "tab-content",
  props: {
    title: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      default: ""
    },
    lazy: {
      type: Boolean,
      default: false
    },
    beforeChange: {
      type: Function
    },
    afterChange: {
      type: Function
    },
    route: {
      type: [String, Object]
    },
    additionalInfo: {
      type: Object,
      default: () => {
      }
    }
  },
  inject: ["addTab", "removeTab"],
  data() {
    return {
      active: false,
      validationError: null,
      checked: false,
      tabId: ""
    };
  },
  computed: {
    shape() {
      return this.$parent.shape;
    },
    color() {
      return this.$parent.color;
    },
    errorColor() {
      return this.$parent.errorColor;
    }
  },
  mounted() {
    this.addTab(this);
  },
  destroyed() {
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
    this.removeTab(this);
  }
};
const _hoisted_1 = ["id", "aria-hidden", "aria-labelledby"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return !$props.lazy || $data.active ? withDirectives((openBlock(), createElementBlock("div", {
    key: 0,
    class: "wizard-tab-container",
    role: "tabpanel",
    id: $data.tabId,
    "aria-hidden": !$data.active,
    "aria-labelledby": `step-${$data.tabId}`
  }, [
    renderSlot(_ctx.$slots, "default", { active: $data.active })
  ], 8, _hoisted_1)), [
    [vShow, $data.active]
  ]) : createCommentVNode("", true);
}
var TabContent = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const VueFormWizard = {
  install(Vue) {
    Vue.component("form-wizard", FormWizard);
    Vue.component("tab-content", TabContent);
    Vue.component("wizard-button", WizardButton);
    Vue.component("wizard-step", WizardStep);
  }
};
export { FormWizard, TabContent, WizardButton, WizardStep, VueFormWizard as default };
